/**
* @file include/retdec/llvmir2hll/hll/bracket_manager.h
* @brief A base class of all BracketManagers.
* @copyright (c) 2017 Avast Software, licensed under the MIT license
*/

#ifndef RETDEC_LLVMIR2HLL_HLL_BRACKET_MANAGER_H
#define RETDEC_LLVMIR2HLL_HLL_BRACKET_MANAGER_H

#include <map>
#include <stack>

#include "retdec/llvmir2hll/support/smart_ptr.h"
#include "retdec/llvmir2hll/support/types.h"
#include "retdec/llvmir2hll/support/visitors/ordered_all_visitor.h"

namespace retdec {
namespace llvmir2hll {

class BinaryOpExpr;
class CastExpr;
class Expression;
class TernaryOpExpr;
class UnaryOpExpr;

/**
* @brief A base class of all brackets managers.
*
* Every brackets manager should subclass this class and override protected
* @c checkPrecTable(...) and @c isOperatorSupported(...) functions.
* In subclass is needed to add a @a Precedence table, which is generated by script
* @a hll_prec_table_gen.py which is in @a /decompiler/scripts/. In @a C/Py/.. HLL Writer
* need to override @c emitTargetCode(...) and call the constructor of subclass
* BracketManager. In constructor of subclass need to place function @c init(...).
*
* Instances of this class have reference object semantics.
*/
class BracketManager: private OrderedAllVisitor {
protected:
	/// Enumeration for operators.
	enum class Operators {
		ADD,
		ADDRESS,
		AND,
		ARRAY,
		ASSIGN,
		BITAND,
		BITOR,
		BITSHL,
		BITSHR,
		BITXOR,
		CALL,
		CAST,
		COMMA,
		DEREF,
		DIV,
		EQ,
		GT,
		GTEQ,
		LT,
		LTEQ,
		MOD,
		MUL,
		NEG,
		NEQ,
		NOT,
		OR,
		STRUCT,
		SUB,
		TERNARY
	};

	/// Enumeration for direction tree traversal.
	enum class Direction {
		CENTER,
		LEFT,
		RIGHT
	};

	/// String constants for L = left-associative, R = right-associative, N = doesn't
	/// mattter, S = skip operator, operator is not supported.
	// It is not a scoped enum (no "class" after "enum") because the code is
	// more readable without the enum's name.
	enum FirstParInItemOfPrecTable {
		L,
		R,
		N,
		S
	};

	/// Structure for one item in precedence table. Structure contains associativity
	/// and status if brackets are needed which is set by priority of operator.
	struct ItemOfPrecTable {
		FirstParInItemOfPrecTable association;
		bool bracketsNeeded;
	};

	/// Structure for one item in prevOperatorsStack. Structure contains previous
	/// operator and direction of tree traversal.
	struct PrevOperators {
		Operators prevOperator;
		Direction treeDirection;
	};

	/// Bool constants.
	static const bool T = true;
	static const bool F = false;
	/// Constant for size of precedence table.
	// Has to correspond to the number of elements in the Operators enum (!).
	static const int PREC_TABLE_SIZE = 29;

private:
	/// Stack of structures. Every structure contains previous operator and direction
	/// of tree traversal.
	std::stack<PrevOperators> prevOperatorsStack;
	/// This map contains Expression adresses and status to write, or doesn't write
	/// brackets.
	std::map<Expression*, bool> bracketsAreNeededMap;
	/// The module to be analyzed.
	Module* module = nullptr;

public:
	BracketManager(Module* module);

	void init();

	/**
	* @brief Returns the ID of the BracketManager.
	*/
	virtual std::string getId() const = 0;

	bool areBracketsNeeded(Expression* expr);

	/// @name OrderedAllVisitor Interface
	/// @{
	using OrderedAllVisitor::visit;
	virtual void visit(AddressOpExpr* expr) override;
	virtual void visit(AssignOpExpr* expr) override;
	virtual void visit(ArrayIndexOpExpr* expr) override;
	virtual void visit(StructIndexOpExpr* expr) override;
	virtual void visit(DerefOpExpr* expr) override;
	virtual void visit(NotOpExpr* expr) override;
	virtual void visit(NegOpExpr* expr) override;
	virtual void visit(EqOpExpr* expr) override;
	virtual void visit(NeqOpExpr* expr) override;
	virtual void visit(LtEqOpExpr* expr) override;
	virtual void visit(GtEqOpExpr* expr) override;
	virtual void visit(LtOpExpr* expr) override;
	virtual void visit(GtOpExpr* expr) override;
	virtual void visit(AddOpExpr* expr) override;
	virtual void visit(SubOpExpr* expr) override;
	virtual void visit(MulOpExpr* expr) override;
	virtual void visit(ModOpExpr* expr) override;
	virtual void visit(DivOpExpr* expr) override;
	virtual void visit(AndOpExpr* expr) override;
	virtual void visit(OrOpExpr* expr) override;
	virtual void visit(BitAndOpExpr* expr) override;
	virtual void visit(BitOrOpExpr* expr) override;
	virtual void visit(BitXorOpExpr* expr) override;
	virtual void visit(BitShlOpExpr* expr) override;
	virtual void visit(BitShrOpExpr* expr) override;
	virtual void visit(TernaryOpExpr* expr) override;
	virtual void visit(CallExpr* expr) override;
	virtual void visit(CommaOpExpr* expr) override;
	// Casts
	virtual void visit(BitCastExpr* expr) override;
	virtual void visit(ExtCastExpr* expr) override;
	virtual void visit(TruncCastExpr* expr) override;
	virtual void visit(FPToIntCastExpr* expr) override;
	virtual void visit(IntToFPCastExpr* expr) override;
	virtual void visit(IntToPtrCastExpr* expr) override;
	virtual void visit(PtrToIntCastExpr* expr) override;
	// Constants
	virtual void visit(ConstBool* constant) override;
	virtual void visit(ConstFloat* constant) override;
	virtual void visit(ConstInt* constant) override;
	virtual void visit(ConstNullPointer* constant) override;
	virtual void visit(ConstString* constant) override;
	virtual void visit(ConstArray* constant) override;
	virtual void visit(ConstStruct* constant) override;
	virtual void visit(ConstSymbol* constant) override;
	// Extra
	virtual void visit(Variable* var) override;
	/// @}

protected:
	virtual ItemOfPrecTable checkPrecTable(Operators currentOperator,
		Operators prevOperator) = 0;
	virtual bool isOperatorSupported(Operators currentOperator) = 0;

	PrevOperators getPrevOperator();

private:
	void addOperatorOnStackIfSupported(Operators currentOperator,
		Direction direction);
	void areBracketsNeededForExpr(Expression* expr,
		Operators currentOperator);
	bool areBracketsNeededPrecTable(Operators currentOperator);
	void removeOperatorFromStackIfSupported(Operators currentOperator);

	void treeTraversalForBinaryOpWithStackOperations(
		BinaryOpExpr* expr, Operators currentOperator);
	void treeTraversalForCallWithStackOperations(
		CallExpr* expr, Operators currentOperator);
	void treeTraversalForCastWithStackOperations(
		CastExpr* expr, Operators currentOperator);
	void treeTraversalForTernaryOpWithStackOperations(
		TernaryOpExpr* expr, Operators currentOperator);
	void treeTraversalForUnaryOpWithStackOperations(
		UnaryOpExpr* expr, Operators currentOperator);
};

} // namespace llvmir2hll
} // namespace retdec

#endif
